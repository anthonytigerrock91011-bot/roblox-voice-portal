// Cloudflare Worker Code: PlayerDataStore (The API Server)

// ðŸš¨ IMPORTANT: Replace the placeholder below with your actual, full .workers.dev URL.
// This is used for a safety check and to ensure WebSockets use the right address.
// EXAMPLE: https://roblox-voice.anthonytigerrock91011.workers.dev
const BASE_WORKER_DOMAIN = "roblox-voice.anthonytigerrock91011.workers.dev";

// The Durable Object class for stateful connections and player data storage
export class PlayerDataStore {
    constructor(state, env) {
        this.state = state;
        this.env = env;
        this.players = {}; 
        this.sessions = new Set(); 
    }

    async fetch(request) {
        const url = new URL(request.url);

        // 1. Roblox POST Endpoint (Updates Player Data)
        if (url.pathname === "/api/update-data" && request.method === "POST") {
            try {
                const playerDataList = await request.json();
                this.players = {};
                playerDataList.forEach(player => {
                    this.players[player.SessionCode] = player;
                });
                
                // Notify all connected website clients of the update
                this.broadcast({ type: "PLAYER_UPDATE", data: Object.values(this.players) });

                return new Response("Data synced successfully.", { status: 200 });
            } catch (error) {
                return new Response("Invalid JSON data.", { status: 400 });
            }
        } 
        
        // 2. Website GET Endpoint (Initial Player Data Fetch)
        else if (url.pathname === "/api/get-players" && request.method === "GET") {
            return new Response(JSON.stringify(Object.values(this.players)), {
                headers: { "Content-Type": "application/json", "Access-Control-Allow-Origin": "*" }
            });
        } 
        
        // 3. Website WebSocket Endpoint (Real-Time Chat Signaling)
        else if (url.pathname === "/api/ws") {
            const upgradeHeader = request.headers.get("Upgrade");
            if (upgradeHeader !== "websocket") {
                return new Response("Expected WebSocket upgrade.", { status: 426 });
            }

            const { 0: client, 1: server } = new WebSocketPair();
            this.state.acceptWebSocket(server);
            this.sessions.add(server);

            server.addEventListener("message", event => this.webSocketMessage(server, event.data));
            server.addEventListener("close", () => this.webSocketClose(server));

            return new Response(null, { status: 101, webSocket: client });
        }

        return new Response("Worker Endpoint Not Found.", { status: 404 });
    }

    async webSocketMessage(ws, message) {
        try {
            const parsed = JSON.parse(message);
            
            if (parsed.type === "REQUEST_CHAT") {
                // Forward the chat request to all connected clients
                this.broadcast({
                    type: "INCOMING_CHAT_REQUEST",
                    senderName: parsed.senderName,
                    senderSessionCode: parsed.senderSessionCode
                });
            }
        } catch (e) {
            console.error("WebSocket message error:", e);
        }
    }
    
    async webSocketClose(ws) {
        this.sessions.delete(ws);
    }
    
    // Broadcast message to all connected clients
    broadcast(message) {
        const payload = JSON.stringify(message);
        this.sessions.forEach(session => {
            try {
                session.send(payload);
            } catch (e) {
                this.sessions.delete(session);
            }
        });
    }
}

// Main Worker handler (routes traffic to the data store)
export default {
    async fetch(request, env) {
        // Simple security check for the worker's own domain
        if (!request.url.includes(BASE_WORKER_DOMAIN)) {
             return new Response("Access Denied or incorrect domain configuration.", { status: 403 });
        }
        
        const id = env.PLAYER_DATA_STORE.idFromName("global_players");
        const stub = env.PLAYER_DATA_STORE.get(id);
        return stub.fetch(request);
    }
};
